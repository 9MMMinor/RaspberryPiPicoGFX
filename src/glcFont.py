from math import cos, sin, pi, radians, ceil, floor

class glcFont(object):
    ''' A class to represent a GLCD font in X-GLCD format

        //Font Generated by MikroElektronika GLCD Font Creator 1.2.0.0
        //MikroElektronika 2011 
        //http://www.mikroe.com '''
    
    def __init__(self, tft, font, monoSp=False, eraseMode=False):
        '''
        Attributes:
            tft: TFT_22_ILI9225 display object.
            font: A bytearray of characters (each row of self.offset bytes represents a character).
                font[0] = width: Maximum pixel width of font.
                font[1] = height: Pixel height of font.
                font[2] = start_char: ASCII ordinate of first character.
                font[3] = number of characters in the bytearray.
                font[offset] = width of character in pixels.
            monoSp: default False, use individual char widths. monoSp=True, use fixed width chars.
            eraseMode: default False, char written without background. eraseMode=True, backgrounds are written.
        '''
        
        self.font = font
        self.width = font[0]
        self.height = font[1]
        self.firstCh = font[2]    # ord of first character in font array. Usually, ord(' '), 32
        self.numberCh = font[3]   # number of consecutive characters in font array. Usually, 96
        self.offset = (floor(
            (self.height - 1) / 8) + 1) * self.width + 1
        self.bytes_per = int(self.height / 8)
        if self.height % 8:
            self.bytes_per += 1
        self.monoSp = monoSp
        self.eraseMode = eraseMode
        self.display = tft
    
    
    def getFontParams(self):
        return [self.offset, self.width, self.height, self.bytes_per]
    
    
    def text(self, x, y, s, color):
        currx = x
        k = 0
        while k < len(s):
            currx += self.drawChar(currx, y, s[k], color) + 1
            k += 1
        return currx


    def getTextWidth(self,s):
        width = 0
        ## Count every character in string ( +1 for spacing )
        k = 0
        while k < len(s):
            width += self.getCharWidth(s[k]) + 1
            k += 1
        return width


    '''
    # This drawChar() "erases" previous character block in both fastMode and drawPixel mode by overwriting the block
    def drawFastChar(self, x, y, ch, color):
        array = self.font
        width = self.width
        height = self.height
        offset = self.offset
        nbrows = self.bytes_per
        monoSp   = self.monoSp
        
        charOffset = (offset * (ord(ch) - self.firstCh)) + 4 #FONT_HEADER_SIZE   ## char offset (add 4 for font header)
        if ( monoSp ):
            charWidth = width       ## monospaced: get char width from font
        else:
            charWidth  = array[int(charOffset)]  ## get chracter width from 1st byte
        charOffset+=1   ## increment pointer to first character data byte

        ## use autoincrement/decrement feature, if character fits completely on screen
        fastMode = ( (x+charWidth+1) < self.display._maxX and (y+height-1) < self.display._maxY )
        if ( fastMode ):
            self.display._setWindow( x, y, x+charWidth+1, y+height-1 )   ## set character Window
        i = 0
        while i <= charWidth:
        ## each font "column" (+1 blank column for spacing)
            h = 0   ## keep track of char height
            j = 0
            while j < nbrows:  ## each column byte
                if (i == charWidth):
                    charData = 0x0  ## Insert blank column
                else:
                    charData = array[int(charOffset)]
                    charOffset+=1
            
            ## Process every row in font character
                x0 = x+i
                y0 = y - (j*8) + height - 1
                k = 0
                while k < 8:
                    if (h >= height ):
                        break   ## No need to process excess bits:
                    if charData & (1<<k):
                        c = color
                    else:
                        c = self.display._bgColor
                    if (fastMode ):
                        self.display._writeData( c )
                    else:
                        self.display.drawPixel( x0, y0-k, c )
                    h += 1
                    k += 1
                j += 1
            i += 1
        if fastMode: self.display._resetWindow()
        return charWidth
    '''

    # This drawChar() uses drawPixel() only, and by default characters must be
    # explicitly erased if they are to be overwritten. To get erasures,
    # eraseMode must be set True, font_object = glcFont(display_object, font_array, eraseMode=True)
    def drawChar(self, x, y, ch, color):
        array = self.font
        width = self.width
        height = self.height
        nbrows = self.bytes_per
        
        charOffset = (self.offset * (ord(ch) - self.firstCh)) + 4 ## char offset (add 4 for font header)
        if self.monoSp:
            charWidth = width       ## monospaced: get char width from font
        else:
            charWidth  = array[int(charOffset)]  ## get chracter width from 1st byte
        charOffset+=1

        i = 0
        while i <= charWidth:
        ## each font "column" (+1 blank column for spacing)
            h = 0   ## keep track of char height
            j = 0
            while j < nbrows:  ## each column byte
                if (i == charWidth):
                    charData = 0x0  ## Insert blank column
                else:
                    charData = array[int(charOffset)]
                    charOffset+=1
            
            ## Process every row in font character
                x0 = x+i
                y0 = y - (j*8) + height - 1
                k = 0
                while k < 8:
                    if (h >= height ):
                        break   ## No need to process excess bits:
                    if charData & (1<<k):
                        self.display.drawPixel( x0, y0-k, color )
                    elif self.eraseMode:
                        self.display.drawPixel( x0, y0-k, self.display._bgColor )
                    h += 1
                    k += 1
                j += 1
            i += 1
        return charWidth


    def getCharWidth(self, ch):
        array = self.font
        charOffset = (self.offset * (ord(ch) - self.firstCh)) + 4 #FONT_HEADER_SIZE   ## char offset (add 4 for font header)
        if self.monoSp:
            charWidth = self.width       ## monospaced: get char width from font
        else:
            charWidth  = array[int(charOffset)]  ## get chracter width from 1st byte
        return int(charWidth)   ## get font width from 1st byte